<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Mustr</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Mustr</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Mustr</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><p align="center">
						<a href="http://github.com/origin1tech/mustr"><img width="150" src="https://raw.githubusercontent.com/origin1tech/mustr/master/assets/logo.png"></a>
					</p>
				<br/></p>
				<h2 id="description">Description</h2>
				<p>Minimalistic scaffolding tool using Mustache Templates</p>
				<p>Scaffolding can be a time saver and helps in consistency for teams. Yeoman is perhaps the most popular tool for this requirement. However building out your own generators can be cumbersome and time consuming. In the end the need is often no more than passing in some params then rendering those params in your template. Mustr attepts to fill that need in a simplistic and declarative way without the hassle and time investment.</p>
				<h2 id="installing-initialization">Installing &amp; Initialization</h2>
				<pre><code class="lang-sh">$ npm install mustr -g
</code></pre>
				<p>Initialize your project for use with Mustr. This will create a mustr.json configuration file along with a folder called Mustr. This folder is where you&#39;ll store your .tpl or template files as well as a file called &quot;register.js&quot;.</p>
				<p>Register.js is where you&#39;ll register your templates. You can register the same template multiple times with unique names keeping your templates DRY (don&#39;t repeat yourself). This is done by registering your template with a callback which allows you to do further manipulation before the template is rendered. We&#39;ll get to more on that in a min.</p>
				<p>Open a terminal at the root of your project and then run:</p>
				<pre><code class="lang-sh">$ mu init
</code></pre>
				<h2 id="options">Options</h2>
				<p>The options are pretty minial and mot much to configure. There are basically three properties in your &quot;mustr.json&quot; file. It is not likely that you&#39;ll need to change these for most projects but in case you do...</p>
				<ul>
					<li>configDir the configuration directory from root usually &quot;./mustr&quot;.</li>
					<li>outputDir the output or where your source files are usually &quot;./src&quot;.</li>
					<li>templateExt the extension used for your templates usually &quot;.tpl&quot;.</li>
					<li>autoRegister auto registers found templates, manually register to override.</li>
				</ul>
				<pre><code class="lang-json">{
  <span class="hljs-attr">"configDir"</span>: <span class="hljs-string">"./mustr"</span>,
  <span class="hljs-attr">"outputDir"</span>: <span class="hljs-string">"./src"</span>,
  <span class="hljs-attr">"templateExt"</span>: <span class="hljs-string">".tpl"</span>,
  <span class="hljs-attr">"autoRegister"</span>: <span class="hljs-literal">true</span>
}
</code></pre>
				<h2 id="defining-templates">Defining Templates</h2>
				<p>Templates are defined using the Mustache templating that you likely already know and yaml front-matter similar to Jekyll or Hugo if you&#39;ve used either before. The front matter allows for defining a configuration for the template but can be used as you&#39;d expect as the metadata for your template also. At first this may seem a bit redundant however it is needed for the config and also allows for defaults for your template. You&#39;ll be able to further modify the metadata for the template as you&#39;ll see in a min below.</p>
				<p>see: <a href="https://www.npmjs.com/package/front-matter">https://www.npmjs.com/package/front-matter</a></p>
				<p>see: <a href="https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a></p>
				<p><strong>Example Template</strong></p>
				<p>There are four simple fields that are required in your front matter config.</p>
				<ul>
					<li>ext - the extension name the file should be saved as (can be overriden)</li>
					<li>type - the suffix name if any that should be applied to the name.</li>
					<li>appendType - appends the component name above to the filename about.service.ts</li>
					<li>casing - the casing strategy for naming the template when rendered. (ex: title for class names)</li>
					<li>injects - definitions that should be inserted in other files upon rendering.</li>
				</ul>
				<p>All other properties as seen below are custom. Again see above on front matter and yaml
				in general for how to create objects, arrays and so on.</p>
				<pre><code class="lang-hbs"><span class="xml">---

config:
  ext: .ts
  type: Service
  casing: title
  injects:
    - filename: 'examples/db.example.tsx'
      find: '// INJECT'
      strategy: 'after'
      insert: "import * as _ from 'lodash';"
      relative: false

props:
  - key: name
    type: string
  - key: age
    type: number

---

export class </span><span class="hljs-template-variable">{{$component.fullname}}</span><span class="xml"> {

  </span><span class="hljs-template-tag">{{#<span class="hljs-name">props</span>}}</span><span class="xml">
  </span><span class="hljs-template-variable">{{key}}</span><span class="xml">: </span><span class="hljs-template-variable">{{type}}</span><span class="xml">;
  </span><span class="hljs-template-tag">{{/<span class="hljs-name">props</span>}}</span><span class="xml">

  constructor() {

  }

}</span>
</code></pre>
				<p><strong>$component</strong></p>
				<p>The $component property is a an injected object into your metadata object used for rendering.
					It&#39;s purpose is to output the following properties for use in generating files and injected
				paths.</p>
				<ul>
					<li>name the name of the file/component without it&#39;s &#39;type&#39; suffix.</li>
					<li>fullname the above name with the type suffix appened if exists.</li>
					<li>group the group name if any the generated template belongs to.</li>
					<li>path the output path of the file being generated.</li>
					<li>from the relative path to the generated file from the file you injected to.</li>
					<li>ext the file extention type.</li>
				</ul>
				<p><strong>The above will result in:</strong></p>
				<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbService</span> </span>{

  name: string;
  age: number;

  <span class="hljs-keyword">constructor</span>() {

  }

}
</code></pre>
				<h2 id="registering-templates">Registering Templates</h2>
				<p>You may notice we did not specify a &quot;component&quot; property in your front matter. You certainly could do that but obviously that kind of defeats the purpose when the desire is to generate a template. This is resolved by injecting the desired component output name you defined in your cli command. We&#39;ll get to that here in a minute.</p>
				<p>For example consider a template named &quot;base.service.tpl&quot;. It might reside in a folder called &quot;services&quot;. Mustr ignores folder structures and focuses on the file name itself. Just makes it easier when looking up templates for registration. For this reason it is important to make all your file names regardless of structure uniquely named although this is not required.</p>
				<p><strong>Example Register.js</strong></p>
				<pre><code class="lang-js">
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mu, Compiler</span>) </span>{

  <span class="hljs-comment">// mu is the Mustr instance.</span>
  <span class="hljs-comment">// Compiler is the template compiling engine. (currently Mustache).</span>

  <span class="hljs-comment">// NAME - the name you wish to register the template under.</span>
  <span class="hljs-comment">// TEMPLATE - the name, path or static string template to use for the registration.</span>
  <span class="hljs-comment">// PARTIALS - string, array of strings, object of key value or multi arg of strings.</span>
  <span class="hljs-comment">// BEFORE_RENDER - callback passing TEMPLATE and done callback.</span>
  <span class="hljs-comment">// AFTER_RENDER - callback passing TEMPLATE.</span>

  <span class="hljs-comment">// Usage:</span>
  mu.register(NAME, TEMPLATE)
    .partials(<span class="hljs-string">'stirng'</span>, <span class="hljs-string">'string'</span>)
    .beforeRender(<span class="hljs-function">(<span class="hljs-params">template, done</span>) =&gt;</span> {  done(); })
    .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {  <span class="hljs-comment">/* do something */</span> });

  <span class="hljs-comment">/* Simple Register
  *******************************************/</span>

  <span class="hljs-comment">// Define name and associated template.</span>
  <span class="hljs-comment">// The first argument is the name you wish to register</span>
  <span class="hljs-comment">// this name will be used when calling:</span>
  <span class="hljs-comment">// mu generate &lt;template&gt; where &lt;template&gt; is</span>
  <span class="hljs-comment">// the registered name.</span>

  <span class="hljs-comment">// The second arg is the path to the template to</span>
  <span class="hljs-comment">// associate to your name or the name of a known</span>
  <span class="hljs-comment">// template (.tpl files are loaded automatically).</span>
  <span class="hljs-comment">// Known templates can be referenced by file name</span>
  <span class="hljs-comment">// without extension. Additionally a static template</span>
  <span class="hljs-comment">// string can be passed directly for inline</span>
  <span class="hljs-comment">// registrations.</span>

  mu.register(<span class="hljs-string">'DB'</span>, <span class="hljs-string">'service'</span>);

  <span class="hljs-comment">/* Group Register
  *******************************************/</span>

  <span class="hljs-comment">// Registering a group allows generating multiple files</span>
  <span class="hljs-comment">// using a single command. It's important to know that</span>
  <span class="hljs-comment">// the group templates must be already registered by</span>
  <span class="hljs-comment">// calling mu.register();</span>

  mu.registerGroup(<span class="hljs-string">'group'</span>, <span class="hljs-string">'template1'</span>, <span class="hljs-string">'template2'</span>);

  <span class="hljs-comment">/* Partials Register
  *******************************************/</span>

  <span class="hljs-comment">// Mustr supports partials as well. You could handle</span>
  <span class="hljs-comment">// partials manually in the callback (see advanced below)</span>
  <span class="hljs-comment">// however in most cases it's easiest to just pass</span>
  <span class="hljs-comment">// the logicless partials in your reigster command.</span>
  <span class="hljs-comment">// They will then be automatically rendered using your</span>
  <span class="hljs-comment">// front matter and/or flags passed in cli.</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials(<span class="hljs-string">'author'</span>);

  <span class="hljs-comment">// OR</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials([<span class="hljs-string">'author'</span>, <span class="hljs-string">'footer'</span>])

  <span class="hljs-comment">// OR</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials(<span class="hljs-string">'header'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-string">'footer'</span>);

  <span class="hljs-comment">/* Advanced Register
  *******************************************/</span>

  <span class="hljs-comment">// When registring with a callback the template can</span>
  <span class="hljs-comment">// be manipulated before rendering.</span>
  <span class="hljs-comment">// For even greater control of each step see</span>
  <span class="hljs-comment">// tests folder to see how you can build</span>
  <span class="hljs-comment">// each step and render manually.</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>)
    .beforeRender(<span class="hljs-function">(<span class="hljs-params">template, done</span>) =&gt;</span> {

      <span class="hljs-comment">// do something with template</span>
      <span class="hljs-comment">// then call done to auto render.</span>
      done();

    })
    .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {

      <span class="hljs-comment">// The file is rendered and written out.</span>
      <span class="hljs-comment">// Below is an example of manually calling</span>
      <span class="hljs-comment">// the .inject() method to inject for example</span>
      <span class="hljs-comment">// an import for the filed created.</span>

      <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> it is probably easier to inline your</span>
      <span class="hljs-comment">// injects in your template. see below for more on that.</span>

      mu.inject(<span class="hljs-string">'path/to/file'</span>, <span class="hljs-string">'search expression'</span>, <span class="hljs-string">'strategy'</span>, <span class="hljs-string">'what to inject'</span>, () =&gt; {
        done();
      });

    });

};
</code></pre>
				<h2 id="generating-templates">Generating Templates</h2>
				<p>Now that we have a template and have registered our templates. We can generate them using the Mustr CLI generate command.</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db
</code></pre>
				<p><strong>The above would create the template at:</strong></p>
				<p>./src/shared/services</p>
				<p><strong>The filename would be:</strong></p>
				<p>db.service.ts</p>
				<p><strong>The component name of the service would be:</strong></p>
				<p>DbService</p>
				<h3 id="how-does-that-work-">How Does That Work?</h3>
				<p><strong>component</strong></p>
				<p>Because our template front-matter config defines a Suffix generated component names and file names will be automatially suffixed with this value. If you&#39;ve used angular-cli this will be familiar to you and probably what you want for your conventions. To remove this feature simply remove this value from your configuration.</p>
				<p><strong>output path</strong></p>
				<p>The mustr.json file defines the source root for your projects so all paths are relative to it for template generation. Hence when we generate a template the path you set in your generation command is respected and output to this location.</p>
				<p><strong>component name</strong></p>
				<p>The component name or the ending value you specified in the output path &quot;shared/services/db&quot; in this case &quot;db&quot; is used for the name of the component/template you&#39;re generating. You&#39;ll notice though that the name is auto suffixed like the file path. This results in this case in &quot;DbService&quot;.</p>
				<p>The filename is auto cased based on your front-matter config using the property &quot;casing&quot;. Valid values are lower, upper, capitalize, title, or camel. Whether you are using suffixes or not Mustr will just figure this out when you specify your desired case. More often than not you want &quot;title&quot; which is essentially titlecase. For anything that is a component/class etc. that&#39;s likely what you want.</p>
				<h2 id="extending-metadata-via-cli">Extending Metadata via CLI</h2>
				<p>Any flags passed in your command line will be respected and overwrite any static metadata used in rendering your template.</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --property value
</code></pre>
				<p>The above will extend or overwrite your metadata object with a key called &quot;property&quot; with the provided &quot;value&quot; as it&#39;s value.</p>
				<p>Nested values are also possible. You could for example have an object in your metadata such as &quot;user&quot;. You override or provide it by doing something like:</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --user name:Bob,age:25
</code></pre>
				<p>OR</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --user.name Bob --user.age 25
</code></pre>
				<h2 id="injecting-imports">Injecting Imports</h2>
				<p>Usually in the ES6 world you will want create an import of the generated/rendered template into another file. Currently this is done only via a callback in your registration as described above.</p>
				<pre><code class="lang-js">mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>)
  .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {

     mu.inject(<span class="hljs-string">'path/to/file'</span>, <span class="hljs-string">'search expression'</span>, <span class="hljs-string">'strategy'</span>, <span class="hljs-string">'what to inject'</span>, () =&gt; {
        done();
      });

  });
</code></pre>
				<p><strong>Inject Inline</strong></p>
				<p>It is also possible to inject inline within your template file. This is done by creating an array in your yaml front-matter. This is very handy as it will create the import to the foriegn file each time a template of this type is created. No fuss no muss just works.</p>
				<pre><code class="lang-yaml">
<span class="hljs-attr">config:</span>
<span class="hljs-attr">  ext:</span> <span class="hljs-string">.ts</span>
<span class="hljs-attr">  component:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">  casing:</span> <span class="hljs-string">title</span>
<span class="hljs-attr">  injects:</span>
<span class="hljs-attr">    - filename:</span> <span class="hljs-string">'examples/db.example.tsx'</span>
<span class="hljs-attr">      find:</span> <span class="hljs-string">'// INJECT'</span>
<span class="hljs-attr">      strategy:</span> <span class="hljs-string">'after'</span>
<span class="hljs-attr">      insert:</span> <span class="hljs-string">"import * as _ from 'lodash';"</span>
</code></pre>
				<h2 id="license">License</h2>
				<p>See <a href="License.md">LICENSE.md</a></p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_cli_.html">"cli"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_interfaces_.html">"interfaces"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>