<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Mustr</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Mustr</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Mustr</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><p align="center">
						<a href="http://github.com/origin1tech/mustr"><img width="150" src="https://raw.githubusercontent.com/origin1tech/mustr/master/assets/logo.png"></a>
					</p>
				<br/></p>
				<h2 id="quick-note">Quick Note</h2>
				<p>Look for exmaples and video tutorial coming this week of July 3, 2017. Although Mustr is not
					overly complicated, appreciate perhaps a little tough to follow at first video will clear it up
				so look for that in the next several days.</p>
				<p><strong>Take note also there was a mistake earlier in the readme as to inline config/metadata via cli.</strong></p>
				<p>Initially this readme read:</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --user name:Bob,age:25
$ mu g db shared/services/db --user.name Bob --user.age 25
</code></pre>
				<p>But SHOULD have been:</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --metadata.user name:Bob,age:25
$ mu g db shared/services/db --metadata.user.name Bob --metadata.user.age 25
</code></pre>
				<p>:(  sorry about that!</p>
				<h2 id="description">Description</h2>
				<p>Minimalistic scaffolding tool using Mustache Templates with handy rollback feature.</p>
				<p>Scaffolding can be a time saver and helps in consistency for teams. Yeoman is perhaps the most popular tool for this requirement. However building out your own generators can be cumbersome and time consuming. In the end the need is often no more than passing in some params then rendering those params in your template. Mustr attempts to fill that need in a simplistic and declarative way without the hassle and time investment. Once you buy in you&#39;ll find it rather trivial to flesh out templates.</p>
				<h2 id="installing-initialization">Installing &amp; Initialization</h2>
				<pre><code class="lang-sh">$ npm install mustr -g
</code></pre>
				<p>Initialize your project for use with Mustr. This will create a mustr.json configuration file along with a folder called Mustr. This folder is where you&#39;ll store your .tpl or template files as well as a file called &quot;register.js&quot;.</p>
				<p>Register.js is where you&#39;ll register your templates. You can register the same template multiple times with unique names keeping your templates DRY (don&#39;t repeat yourself). This is done by registering your template with a callback which allows you to do further manipulation before the template is rendered. We&#39;ll get to more on that in a min.</p>
				<p>Open a terminal at the root of your project and then run:</p>
				<pre><code class="lang-sh">$ mu init
</code></pre>
				<h2 id="options">Options</h2>
				<p>The options are pretty minial and mot much to configure. There are basically three properties in your &quot;mustr.json&quot; file. It is not likely that you&#39;ll need to change these for most projects but in case you do...</p>
				<ul>
					<li>configDir the configuration directory from root usually &quot;./mustr&quot;.</li>
					<li>outputDir the output or where your source files are usually &quot;./src&quot;.</li>
					<li>templateExt the extension used for your templates usually &quot;.tpl&quot;.</li>
					<li>autoLoad when true auto loads templates/config, only need to set to false if loading Mustr manually.</li>
					<li>autoRegister auto registers found templates, manually register to override.</li>
					<li>maxRollbacks the maximum number of rollbacks to store before pruning.</li>
				</ul>
				<p>The following properties are valid only when passing a config
					object into Mustr manually when initializing instance. These
					options cannot be set in your mustr.json file however you can
				set the engine and renderer in your register.js file by calling:</p>
				<ul>
					<li>Engine the custom compiling engine to use instead of Mustache.</li>
					<li>renderer the rendering function to render out the template.</li>
				</ul>
				<pre><code class="lang-js">mu.setEngine(Compiler, renderer);
</code></pre>
				<p>see below for an example using Jade.</p>
				<pre><code class="lang-json">{
  &quot;configDir&quot;: &quot;./mustr&quot;,
  &quot;outputDir&quot;: &quot;./src&quot;,
  &quot;templateExt&quot;: &quot;.tpl&quot;,
  &quot;autoLoad&quot;: true,
  &quot;autoRegister&quot;: true,
  &quot;maxRollbacks&quot; 15
}
</code></pre>
				<h2 id="defining-templates">Defining Templates</h2>
				<p>Templates are defined using the Mustache templating that you likely already know and yaml front-matter similar to Jekyll or Hugo if you&#39;ve used either before. The front matter allows for defining a configuration for the template but can be used as you&#39;d expect as the metadata for your template also. At first this may seem a bit redundant however it is needed for the config and also allows for defaults for your template. You&#39;ll be able to further modify the metadata for the template as you&#39;ll see in a min below.</p>
				<p>see: <a href="https://www.npmjs.com/package/front-matter">https://www.npmjs.com/package/front-matter</a></p>
				<p>see: <a href="https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a></p>
				<p><strong>Example Template</strong></p>
				<p>There are four simple fields that are required in your front matter config.</p>
				<ul>
					<li>ext - the extension name the file should be saved as (can be overriden)</li>
					<li>type - the suffix name if any that should be applied to the name.</li>
					<li>appendType - appends the component name above to the filename about.service.ts</li>
					<li>casing - the casing strategy for naming the template when rendered. (ex: title for class names)</li>
					<li>filenameCasing - same as above but will set the casing for the filename itself.</li>
					<li>outputDir - changes the relative base path for generated templates instead of you global config.</li>
					<li>outputPath - a static output path to be used rather than relative to config.</li>
					<li>rename - useful when generating components, will rename the generated template to this name.</li>
					<li>injects - definitions that should be inserted in other files upon rendering.</li>
					<li><p>paths - key value pairs string split by | ex: &#39;./my/path.ts|./my/other/path&#39;</p>
						<p>Note on paths. The first path is the from path the second is the to path.
						Essentially the used to get the relative path from the to path.</p>
					</li>
				</ul>
				<p>All other properties as seen below are custom. Again see above on front matter and yaml
				in general for how to create objects, arrays and so on.</p>
				<pre><code class="lang-hbs"><span class="xml">---

$config:
  ext: .ts
  type: Service
  casing: title
  injects:
    - filename: 'examples/db.example.tsx'
      find: '// INJECT'
      strategy: 'after'
      insert: "import * as _ from 'lodash';"
      relative: false

props:
  - key: name
    type: string
  - key: age
    type: number

---

export class </span><span class="hljs-template-variable">{{$component.fullname}}</span><span class="xml"> {

  </span><span class="hljs-template-tag">{{#<span class="hljs-name">props</span>}}</span><span class="xml">
  </span><span class="hljs-template-variable">{{key}}</span><span class="xml">: </span><span class="hljs-template-variable">{{type}}</span><span class="xml">;
  </span><span class="hljs-template-tag">{{/<span class="hljs-name">props</span>}}</span><span class="xml">

  constructor() {

  }

}</span>
</code></pre>
				<p><strong>$component</strong></p>
				<p>The $component property is a an injected object into your metadata object used for rendering.
					It&#39;s purpose is to output the following properties for use in generating files and injected
				paths.</p>
				<ul>
					<li>name the name of the file/component without it&#39;s &#39;type&#39; suffix.</li>
					<li>fullname the above name with the type suffix appened if exists.</li>
					<li>group the group name if any the generated template belongs to basically the component name.</li>
					<li>path the output path of the file being generated.</li>
					<li>from the relative path to the generated file from the file you injected to.</li>
					<li>ext the file extention type.</li>
				</ul>
				<p><strong>The above will result in:</strong></p>
				<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DbService</span> </span>{

  name: string;
  age: number;

  <span class="hljs-keyword">constructor</span>() {

  }

}
</code></pre>
				<h2 id="registering-templates">Registering Templates</h2>
				<p>You may notice we did not specify a &quot;component&quot; property in your front matter. You certainly could do that but obviously that kind of defeats the purpose when the desire is to generate a template. This is resolved by injecting the desired component output name you defined in your cli command. We&#39;ll get to that here in a minute.</p>
				<p>For example consider a template named &quot;base.service.tpl&quot;. It might reside in a folder called &quot;services&quot;. Mustr ignores folder structures and focuses on the file name itself. Just makes it easier when looking up templates for registration. For this reason it is important to make all your file names regardless of structure uniquely named although this is not required.</p>
				<p><strong>Example Register.js</strong></p>
				<pre><code class="lang-js">
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mu, Engine</span>) </span>{

  <span class="hljs-comment">// mu is the Mustr instance.</span>
  <span class="hljs-comment">// Engine is the template compiling engine. (currently Mustache).</span>

  <span class="hljs-comment">// NAME - the name you wish to register the template under.</span>
  <span class="hljs-comment">// TEMPLATE - the name, path or static string template to use for the registration.</span>
  <span class="hljs-comment">// PARTIALS - string, array of strings, object of key value or multi arg of strings.</span>
  <span class="hljs-comment">// BEFORE_RENDER - callback passing TEMPLATE and done callback.</span>
  <span class="hljs-comment">// AFTER_RENDER - callback passing TEMPLATE.</span>

  <span class="hljs-comment">// Usage:</span>
  mu.register(NAME, TEMPLATE)
    .partials(<span class="hljs-string">'stirng'</span>, <span class="hljs-string">'string'</span>)
    .beforeRender(<span class="hljs-function">(<span class="hljs-params">template, done</span>) =&gt;</span> {  done(); })
    .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {  <span class="hljs-comment">/* do something */</span> });

  <span class="hljs-comment">/* Simple Register
  *******************************************/</span>

  <span class="hljs-comment">// Define name and associated template.</span>
  <span class="hljs-comment">// The first argument is the name you wish to register</span>
  <span class="hljs-comment">// this name will be used when calling:</span>
  <span class="hljs-comment">// mu generate &lt;template&gt; where &lt;template&gt; is</span>
  <span class="hljs-comment">// the registered name.</span>

  <span class="hljs-comment">// The second arg is the path to the template to</span>
  <span class="hljs-comment">// associate to your name or the name of a known</span>
  <span class="hljs-comment">// template (.tpl files are loaded automatically).</span>
  <span class="hljs-comment">// Known templates can be referenced by file name</span>
  <span class="hljs-comment">// without extension. Additionally a static template</span>
  <span class="hljs-comment">// string can be passed directly for inline</span>
  <span class="hljs-comment">// registrations.</span>

  mu.register(<span class="hljs-string">'DB'</span>, <span class="hljs-string">'service'</span>);

  <span class="hljs-comment">/* Component Register
  *******************************************/</span>

  <span class="hljs-comment">// Registering a component allows generating multiple files</span>
  <span class="hljs-comment">// using a single command. It's important to know that</span>
  <span class="hljs-comment">// the component templates must be already registered by</span>
  <span class="hljs-comment">// calling mu.register();</span>

  mu.registerComponent(<span class="hljs-string">'group'</span>, <span class="hljs-string">'template1'</span>, <span class="hljs-string">'template2'</span>);

  <span class="hljs-comment">/* Partials Register
  *******************************************/</span>

  <span class="hljs-comment">// Mustr supports partials as well. You could handle</span>
  <span class="hljs-comment">// partials manually in the callback (see advanced below)</span>
  <span class="hljs-comment">// however in most cases it's easiest to just pass</span>
  <span class="hljs-comment">// the logicless partials in your reigster command.</span>
  <span class="hljs-comment">// They will then be automatically rendered using your</span>
  <span class="hljs-comment">// front matter and/or flags passed in cli.</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials(<span class="hljs-string">'author'</span>);

  <span class="hljs-comment">// OR</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials([<span class="hljs-string">'author'</span>, <span class="hljs-string">'footer'</span>])

  <span class="hljs-comment">// OR</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>).partials(<span class="hljs-string">'header'</span>, <span class="hljs-string">'author'</span>, <span class="hljs-string">'footer'</span>);

  <span class="hljs-comment">/* Advanced Register
  *******************************************/</span>

  <span class="hljs-comment">// When registring with a callback the template can</span>
  <span class="hljs-comment">// be manipulated before rendering.</span>
  <span class="hljs-comment">// For even greater control of each step see</span>
  <span class="hljs-comment">// tests folder to see how you can build</span>
  <span class="hljs-comment">// each step and render manually.</span>

  mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>)
    .beforeRender(<span class="hljs-function">(<span class="hljs-params">template, done</span>) =&gt;</span> {

      <span class="hljs-comment">// do something with template</span>
      <span class="hljs-comment">// then call done to auto render.</span>
      done();

    })
    .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {

      <span class="hljs-comment">// The file is rendered and written out.</span>
      <span class="hljs-comment">// Below is an example of manually calling</span>
      <span class="hljs-comment">// the .inject() method to inject for example</span>
      <span class="hljs-comment">// an import for the filed created.</span>

      <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> it is probably easier to inline your</span>
      <span class="hljs-comment">// injects in your template. see below for more on that.</span>

      mu.inject(<span class="hljs-string">'path/to/file'</span>, <span class="hljs-string">'search expression'</span>, <span class="hljs-string">'strategy'</span>, <span class="hljs-string">'what to inject'</span>, () =&gt; {
        done();
      });

    });

    <span class="hljs-comment">/* Changing Template Engine
    *******************************************/</span>

    <span class="hljs-comment">// Don't like Mustache? You can use whatever</span>
    <span class="hljs-comment">// templating engine you wish. Mustr merely</span>
    <span class="hljs-comment">// handles some fancy things for paths and</span>
    <span class="hljs-comment">// front matter/metadata. You can use whatever</span>
    <span class="hljs-comment">// rendering engine you wish.</span>

    <span class="hljs-keyword">const</span> Jade = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jade'</span>);
    <span class="hljs-keyword">const</span> renderer = <span class="hljs-function">(<span class="hljs-params">body, meta, <span class="hljs-regexp">/* optional object of partials here */</span></span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> template = jade.compile(body, <span class="hljs-comment">/* jade options */</span>);
        <span class="hljs-keyword">return</span> template(meta);
    }
    mu.setEngine(Jade, renderer);

};
</code></pre>
				<h2 id="generating-templates">Generating Templates</h2>
				<p>Now that we have a template and have registered our templates. We can generate them using the Mustr CLI generate command.</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db
</code></pre>
				<p><strong>The above would create the template at:</strong></p>
				<p>./src/shared/services</p>
				<p><strong>The filename would be:</strong></p>
				<p>db.service.ts</p>
				<p><strong>The component name of the service would be:</strong></p>
				<p>DbService</p>
				<h3 id="how-does-that-work-">How Does That Work?</h3>
				<p><strong>component</strong></p>
				<p>Because our template front-matter config defines a type the generated component names and file names will be automatially suffixed with this value. If you&#39;ve used angular-cli this will be familiar to you and probably what you want for your conventions.</p>
				<p><strong>output path</strong></p>
				<p>The mustr.json file defines the source root for your projects so all paths are relative to it for template generation. Hence when we generate a template the path you set in your generation command is respected and output to this location. You can also specify in your template&#39;s config that the template has a base &quot;outputDir&quot; which then assumes the template should be generated relative to that specified path rather than the global config path. You can also statically set the path. Imagine for example a LICENSE or README.md. It&#39;s likely these types of files will always output to the same root directory.</p>
				<p><strong>component name</strong></p>
				<p>The component name or the ending value you specified in the output path &quot;shared/services/db&quot; in this case &quot;db&quot; is used for the name of the component/template you&#39;re generating. You&#39;ll notice though that the name is auto suffixed like the file path. This results in this case in &quot;DbService&quot;.</p>
				<p>The filename is auto cased based on your front-matter config using the property &quot;casing&quot;. Valid values are lower, upper, capitalize, title, or camel. Whether you are using suffixes or not Mustr will just figure this out when you specify your desired case. More often than not you want &quot;title&quot; which is essentially titlecase. For anything that is a component/class etc. that&#39;s likely what you want.</p>
				<h2 id="extending-metadata-via-cli">Extending Metadata via CLI</h2>
				<p>Any flags passed in your command line will be respected and overwrite any config or static metadata used in rendering your template.</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --property value
</code></pre>
				<p>The above will extend or overwrite your metadata object with a key called &quot;property&quot; with the provided &quot;value&quot; as it&#39;s value.</p>
				<p>Nested values are also possible. You could for example have an object in your metadata such as &quot;user&quot;. You override or provide it by doing something like:</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --metadata.user name:Bob,age:25
</code></pre>
				<p>OR</p>
				<pre><code class="lang-sh">$ mu g db shared/services/db --metadata.user.name Bob --metadata.user.age 25
</code></pre>
				<h2 id="injecting-imports">Injecting Imports</h2>
				<p>Usually in the ES6 world you will want create an import of the generated/rendered template into another file. Currently this is done only via a callback in your registration as described above.</p>
				<pre><code class="lang-js">mu.register(<span class="hljs-string">'Db'</span>, <span class="hljs-string">'service'</span>)
  .afterRender(<span class="hljs-function">(<span class="hljs-params">template</span>) =&gt;</span> {

     mu.inject(<span class="hljs-string">'path/to/file'</span>, <span class="hljs-string">'search expression'</span>, <span class="hljs-string">'strategy'</span>, <span class="hljs-string">'what to inject'</span>, () =&gt; {
        done();
      });

  });
</code></pre>
				<p><strong>Inject Inline</strong></p>
				<p>It is also possible to inject inline within your template file. This is done by creating an array in your yaml front-matter. This is very handy as it will create the import to the foriegn file each time a template of this type is created. No fuss no muss just works.</p>
				<pre><code class="lang-yaml">
<span class="hljs-string">$config:</span>
<span class="hljs-attr">  ext:</span> <span class="hljs-string">.ts</span>
<span class="hljs-attr">  type:</span> <span class="hljs-string">Service</span>
<span class="hljs-attr">  casing:</span> <span class="hljs-string">title</span>
<span class="hljs-attr">  injects:</span>
<span class="hljs-attr">    - filename:</span> <span class="hljs-string">'examples/db.example.tsx'</span>
<span class="hljs-attr">      find:</span> <span class="hljs-string">'// INJECT'</span>
<span class="hljs-attr">      strategy:</span> <span class="hljs-string">'after'</span>
<span class="hljs-attr">      insert:</span> <span class="hljs-string">"import * as _ from 'lodash';"</span>
</code></pre>
				<h2 id="rollbacks">Rollbacks</h2>
				<p>Rollbacks are a handy feature of Mustr. They enable you to quickly rollback to previously generated versions of your components. Not likely that you&#39;ll use this feature often but when you need it, it&#39;s extremely useful.</p>
				<p><strong>Rollback by ID</strong></p>
				<pre><code class="lang-sh">$ mu rollback 11388399399-view
</code></pre>
				<p>TIP: to view a list of valid rollback ids you can run the command:</p>
				<pre><code class="lang-sh">$ mu show rollbacks
</code></pre>
				<p><strong>Rollback by Index</strong></p>
				<p>After showing current rollback entries you&#39;ll notice each entry corresponds to an
					index. You can also specify the index and Mustr will sort out which rollback id
				it corresponds to. Saves some typing.</p>
				<pre><code class="lang-sh">$ mu rollback 3
</code></pre>
				<p><strong>Rollback by Last</strong></p>
				<p>You can also call rollback with no arguments and the last rollback id will be
				automatically selected. Great for whoops I blew that moments.</p>
				<pre><code class="lang-sh">$ mu rollback
</code></pre>
				<p>The above would get the third rollback&#39;s rollback id and then pass to the &quot;rollback&quot; method in Mustr.</p>
				<p><strong>Rollback Manually</strong></p>
				<p>WARNING: this merely removes the template, useful in the sense that
					you can specify the same params you did when you generated it and
					Mustr will sort out the rest. Essentially say you generated a template
					and just want to remove it you could press up arrow in your console
					then change the &quot;g&quot; or &quot;generate&quot; command to &quot;r&quot; or &quot;rollback&quot;.
				That said always rollback by an id if possible.</p>
				<pre><code class="lang-sh">$ mu rollback template output/path
</code></pre>
				<h2 id="license">License</h2>
				<p>See <a href="License.md">LICENSE.md</a></p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_cli_.html">"cli"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_interfaces_.html">"interfaces"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>